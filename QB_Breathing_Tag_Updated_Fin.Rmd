---
title: "Quiet_Breathing_Calc"
output: html_document
date: "2024-10-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Function to install and load necessary packages
install_if_missing <- function(packages) {
  for (package in packages) {
    if (!require(package, character.only = TRUE)) {
      install.packages(package, dependencies = TRUE)
      library(package, character.only = TRUE)
    }
  }
}

# List of required packages
required_packages <- c("readxl", "dplyr", "gridExtra", "grid", "lubridate", "openxlsx", "ggplot2", "stringr", "purrr")

# Install and load required packages
install_if_missing(required_packages)

# Load necessary libraries
library(readxl)
library(dplyr)
library(gridExtra)
library(grid)
library(lubridate)
library(purrr)
library(stringr)
library(openxlsx)
library(ggplot2)
```

```{r}
# Prompt user to select an Excel file
file_path <- file.choose()
# Extract the file name without extension
file_name <- tools::file_path_sans_ext(basename(file_path))
# Read the Excel file
data <- read_excel(file_path)

# Ensure the required columns exist, including "Protocol Type"
required_columns <- c("Te (msec)", "Ti (msec)", "MV", "TV", "PIF", "PEF", "RT (msec)", "P (msec)", "f (bpm)", "Penh", "Protocol Type")
if (!all(required_columns %in% colnames(data))) {
  stop("The required columns are not present in the data.")
}
```

```{r}
# Helper Functions
resolve_multiclass <- function(tags_str) {
  if (is.na(tags_str) || tags_str == "") return(NA_real_)
  flag_vec <- unlist(strsplit(tags_str, ","))
  if ("3.1" %in% flag_vec) return(3.1)  # Post-sigh apnea
  if ("4" %in% flag_vec) return(4)      # Hypopnea
  if ("3" %in% flag_vec) return(3)      # Apnea
  if ("1" %in% flag_vec) return(1)      # Sigh
  if ("2" %in% flag_vec) return(2)      # Sniff
  if ("0" %in% flag_vec) return(0)      # QB (lowest priority)
  return(as.numeric(flag_vec[1]))
}

recalc_qb_tags_and_averages <- function(df) {
  if (!"QB Tag" %in% names(df)) stop("Error: 'QB Tag' column is missing.")
  
  df <- df %>%
    group_by(`QB Tag`) %>%
    mutate(breath_count = n()) %>%
    ungroup() %>%
    mutate(`QB Tag` = ifelse(breath_count < 10, NA, `QB Tag`)) %>%
    select(-breath_count) %>%
    mutate(`QB Tag` = as.integer(factor(`QB Tag`)))
  
  df <- df %>%
    mutate(
      `Avg Ti` = NA_real_, `Avg Te` = NA_real_, `Avg PIF` = NA_real_,
      `Avg PEF` = NA_real_, `Avg TV` = NA_real_, `Avg RT` = NA_real_,
      `Avg MV` = NA_real_, `Avg P` = NA_real_, `Avg Frequency` = NA_real_, `Avg Penh` = NA_real_,
      `Avg Total` = NA_real_
    )
  
  unique_tags <- unique(df$`QB Tag`) %>% na.omit()
  for (tag in unique_tags) {
    rows_tag <- df$`QB Tag` == tag
    df$`Avg Ti`[rows_tag] <- mean(df$`Ti (msec)`[rows_tag], na.rm = TRUE)
    df$`Avg Te`[rows_tag] <- mean(df$`Te (msec)`[rows_tag], na.rm = TRUE)
    df$`Avg PIF`[rows_tag] <- mean(df$PIF[rows_tag], na.rm = TRUE)
    df$`Avg PEF`[rows_tag] <- mean(df$PEF[rows_tag], na.rm = TRUE)
    df$`Avg TV`[rows_tag] <- mean(df$TV[rows_tag], na.rm = TRUE)
    df$`Avg RT`[rows_tag] <- mean(df$`RT (msec)`[rows_tag], na.rm = TRUE)
    df$`Avg MV`[rows_tag] <- mean(df$`MV`[rows_tag], na.rm = TRUE)
    df$`Avg P`[rows_tag] <- mean(df$`P (msec)`[rows_tag], na.rm = TRUE)
    df$`Avg Frequency`[rows_tag] <- mean(df$`f (bpm)`[rows_tag], na.rm = TRUE)
    df$`Avg Penh`[rows_tag] <- mean(df$Penh[rows_tag], na.rm = TRUE)
    df$`Avg Total`[rows_tag] <- mean(df$Ttotal[rows_tag], na.rm = TRUE)
  }
  
  qb_rows <- df[!is.na(df$`QB Tag`), ]
  cat("QB Tag counts:\n")
  print(table(df$`QB Tag`, useNA = "ifany"))
  cat("Number of QB rows:", nrow(qb_rows), "\n")
  
  dataset_wide_averages <- if (nrow(qb_rows) == 0) {
    data.frame(Metric = c("Average Ti", "Average Te", "Average PIF", "Average PEF", "Average TV", "Average RT", "Average MV", "Average P", "Average Frequency", "Average Penh", "Average Total"), Value = rep(0, 11))
  } else {
    data.frame(
      Metric = c("Average Ti", "Average Te", "Average PIF", "Average PEF", "Average TV", "Average RT", "Average MV", "Average P", "Average Frequency", "Average Penh", "Average Total"),
      Value = c(
        mean(qb_rows$`Ti (msec)`, na.rm = TRUE), mean(qb_rows$`Te (msec)`, na.rm = TRUE), mean(qb_rows$PIF, na.rm = TRUE),
        mean(qb_rows$PEF, na.rm = TRUE), mean(qb_rows$TV, na.rm = TRUE), mean(qb_rows$`RT (msec)`, na.rm = TRUE),mean(qb_rows$`MV`, na.rm = TRUE),
        mean(qb_rows$`P (msec)`, na.rm = TRUE), mean(qb_rows$`f (bpm)`, na.rm = TRUE), mean(qb_rows$Penh, na.rm = TRUE),
        mean(qb_rows$Ttotal, na.rm = TRUE)
      )
    )
  }
  cat("Dataset-wide averages:\n")
  print(dataset_wide_averages)
  
  attr(df, "dataset_wide_averages") <- dataset_wide_averages
  df
}

recalculate_qb_variability <- function(df) {
  df <- df %>%
    group_by(`QB Tag`) %>%
    mutate(
      # QB Variability: % change from previous Ttotal, NA for first in group
      Ttotal_lag = lag(Ttotal),
      `QB Variability` = ifelse(is.na(Ttotal_lag), NA_real_, 
                                abs((Ttotal - Ttotal_lag) / Ttotal_lag) * 100),
      `QB Variability` = ifelse(is.infinite(`QB Variability`), NA_real_, `QB Variability`)
    ) %>%
    ungroup()
  
# QB_Var_Dev: % change between consecutive QB Variability values, starting at third row
  df$`QB_Var_Dev` <- NA_real_
  qb_indices <- which(!is.na(df$`QB Tag`))
  
  if (length(qb_indices) > 2) {  # Need at least 3 rows for deviation
    # Group by QB Tag to handle sessions separately
    qb_groups <- split(qb_indices, df$`QB Tag`[qb_indices])
    for (group_indices in qb_groups) {
      if (length(group_indices) > 2) {  # Ensure at least 3 rows in this session
        for (i in 3:length(group_indices)) {  # Start at third row
          curr_idx <- group_indices[i]
          prev_idx <- group_indices[i - 1]  # Second-to-last QB row
          prev_prev_idx <- group_indices[i - 2]  # Third-to-last QB row
          if (!is.na(df$`QB Variability`[curr_idx]) && 
              !is.na(df$`QB Variability`[prev_idx]) && 
              df$`QB Variability`[prev_idx] != 0) {
            df$`QB_Var_Dev`[curr_idx] <- 
              abs((df$`QB Variability`[curr_idx] - df$`QB Variability`[prev_idx]))
          } else {
            df$`QB_Var_Dev`[curr_idx] <- NA_real_  # Handle zero or NA prior variability
          }
        }
      }
    }
  }
  
  # Remove temporary lag column
  df <- df %>% select(-Ttotal_lag)
  
  return(df)
}
```

```{r}
# Step 1: Create Stable Index
data <- data %>%
  mutate(
    orig_index = row_number(),
    Ttotal = `Te (msec)` + `Ti (msec)`,
    Frequency = `f (bpm)`,
    `QB Tag` = NA_integer_,
    `QB Variability` = NA_real_, `QB_Var_Dev` = NA_real_,
    `Avg Ti` = NA_real_, `Avg Te` = NA_real_, `Avg PIF` = NA_real_,
    `Avg PEF` = NA_real_, `Avg TV` = NA_real_, `Avg RT` = NA_real_, `Avg MV` = NA_real_,
    `Avg P` = NA_real_, `Avg Frequency` = NA_real_, `Avg Penh` = NA_real_,
    `Avg Total` = NA_real_, `Breathing Class` = NA_real_
  )
```

```{r}
# Step 1.5: Identify baseline periods, separating sequential challenges
## and adding a debug check.

# Baseline protocol types (extend as needed)
baseline_protocol <- c("Quiet Breathing", "Normoxia Baseline")

# First, create a unique ID for each contiguous block of a given Protocol Type.
## This ensures that two stages with the same name separated by another different challenge are treated as two unique events.
data <- data %>%
  # A "change" occurs if the current protocol is different from the previous one
  mutate(protocol_change = `Protocol Type` != lag(`Protocol Type`, default = first(`Protocol Type`))) %>%
  # The cumulative sum of these changes creates a unique ID for each block
  mutate(protocol_block_id = cumsum(protocol_change))

# Define protocols to exclude from being a "challenge"
protocols_to_exclude <- c(baseline_protocol, "Acclimation")
challenge_protocols <- unique(data$`Protocol Type`[!data$`Protocol Type` %in% protocols_to_exclude])

# Calculate cumulative time within each unique protocol block to find the last 2 minutes
challenge_data <- data %>%
  # Add Ttotal if it's not already there
  mutate(Ttotal = `Te (msec)` + `Ti (msec)`) %>%
  # Filter for challenge protocols only
  filter(`Protocol Type` %in% challenge_protocols) %>%
  # Group by the unique block ID to process them independently
  group_by(protocol_block_id, `Protocol Type`) %>%
  # Calculate cumulative time from the start of each challenge
  mutate(cumulative_time_msec = cumsum(Ttotal)) %>%
  # Find the end time for each challenge
  mutate(end_time_msec = max(cumulative_time_msec)) %>%
  # Filter for rows within the last 2 minutes (120,000 milliseconds)
  filter(cumulative_time_msec > (end_time_msec - 120000)) %>%
  # Ungroup to be safe
  ungroup()

# DEBUG: Create and print a summary of the intervals identified for each challenge block.
challenge_intervals_summary <- challenge_data %>%
  group_by(protocol_block_id, `Protocol Type`) %>%
  summarise(
    start_index = min(orig_index),
    end_index = max(orig_index),
    .groups = "drop"
  )

cat("--- Debug Check: Identified Challenge Intervals ---\n")
print(challenge_intervals_summary)
cat("--------------------------------------------------\n\n")


# Pull the original row numbers of these specific breaths to be used later
challenge_indices <- challenge_data %>% pull(orig_index)

# Create a new column 'is_baseline_candidate' to flag all rows for analysis.
# This includes all "Quiet Breathing" rows and the challenge rows identified above.
data <- data %>%
  mutate(is_baseline_candidate = ((`Protocol Type` %in% baseline_protocol) & 
                                    !is.na(`Period Time`)
                                  ) | (orig_index %in% challenge_indices)
         )

```

```{r}
# Step 2 & 3: QB Tagging and Iterative Refinement
baseline_subset <- data %>%
  filter(is_baseline_candidate == TRUE, !is.na(`Period Time`))
qb_tag_counter <- 0
in_qb_session <- FALSE
last_Ttotal <- NA_real_
consecutive_non_qb <- 0
previous_protocol <- NA

for (i in seq_len(nrow(baseline_subset))) {
  current_protocol <- baseline_subset$`Protocol Type`[i]
  freq_i <- baseline_subset$Frequency[i]
  
  # Check for protocol type change within an ongoing QB session
  if (i > 1 && current_protocol != previous_protocol && in_qb_session) {
    if (!is.na(freq_i) && freq_i <= 250) {
      # Continue the QB session but reset last_Ttotal
      last_Ttotal <- baseline_subset$Ttotal[i]
      baseline_subset$`QB Tag`[i] <- qb_tag_counter
      consecutive_non_qb <- 0
    } else {
      # End the QB session
      in_qb_session <- FALSE
      consecutive_non_qb <- 0
      baseline_subset$`QB Tag`[i] <- NA
    }
  } else {
    # Original logic for rows without protocol type change
    if (!is.na(freq_i) && freq_i <= 250) {
      if (!in_qb_session) {
        qb_tag_counter <- qb_tag_counter + 1
        baseline_subset$`QB Tag`[i] <- qb_tag_counter
        in_qb_session <- TRUE
        last_Ttotal <- baseline_subset$Ttotal[i]
        consecutive_non_qb <- 0
      } else {
        current_var <- if (!is.na(last_Ttotal) && last_Ttotal != 0) 
          abs((baseline_subset$Ttotal[i] - last_Ttotal) / last_Ttotal) * 100 
          else NA_real_
        if (!is.na(current_var) && current_var < 40) {
          baseline_subset$`QB Tag`[i] <- qb_tag_counter
          consecutive_non_qb <- 0
          last_Ttotal <- baseline_subset$Ttotal[i]
        } else {
          baseline_subset$`QB Tag`[i] <- NA
          consecutive_non_qb <- consecutive_non_qb + 1
          if (consecutive_non_qb >= 4) in_qb_session <- FALSE
        }
      }
    } else {
      baseline_subset$`QB Tag`[i] <- NA
      consecutive_non_qb <- consecutive_non_qb + 1
      if (in_qb_session && consecutive_non_qb >= 4) in_qb_session <- FALSE
    }
  }
  previous_protocol <- current_protocol
}

# Merge initial QB tags back to data
data <- data %>%
  left_join(baseline_subset %>% select(orig_index, `QB Tag`), by = "orig_index", suffix = c("", "_new")) %>%
  mutate(`QB Tag` = coalesce(`QB Tag_new`, `QB Tag`)) %>%
  select(-`QB Tag_new`)
```

```{r}
# Step 3-4: Iterative Refinement

# Iterative Loop
changes_made <- TRUE
iteration_count <- 0
max_iter <- 25

while (changes_made && iteration_count < max_iter) {
  iteration_count <- iteration_count + 1
  changes_made <- FALSE
  
  # Filter for baseline subset
  baseline_subset <- data %>%
  filter(`Protocol Type` %in% baseline_protocol, !is.na(`Period Time`))
  
  baseline_subset <- recalc_qb_tags_and_averages(baseline_subset)
  baseline_averages <- attr(baseline_subset, "dataset_wide_averages")
  
  baseline_subset <- recalculate_qb_variability(baseline_subset)
  
  # Filter rows where QB_Var_Dev > 40 or Ttotal/TV is 0
  highvar_rows <- which(
    !is.na(baseline_subset$`QB Tag`) & 
    (
      (!is.na(baseline_subset$QB_Var_Dev) & baseline_subset$QB_Var_Dev > 40) |
      baseline_subset$Ttotal == 0 |
      baseline_subset$TV == 0
    )
  )
  
  if (length(highvar_rows) > 0) {
    baseline_subset$`QB Tag`[highvar_rows] <- NA_integer_
    
    baseline_subset <- baseline_subset %>%
      mutate(
        across(starts_with("Avg"), ~ NA_real_),
        `QB Variability` = NA_real_,
        QB_Var_Dev = NA_real_
      )
    
    changes_made <- TRUE
    
    cat(
      "Iteration", iteration_count,
      "- Removed", length(highvar_rows), "rows at indices:",
      baseline_subset$orig_index[highvar_rows], "\n"
    )
    
    # Recalculate after removal
    baseline_subset <- recalculate_qb_variability(baseline_subset)
  }
  
  # Update data directly for rows in baseline_subset
  matching_rows <- match(baseline_subset$orig_index, data$orig_index)
  
  data$`QB Tag`[matching_rows] <- baseline_subset$`QB Tag`
  data$`QB Variability`[matching_rows] <- baseline_subset$`QB Variability`
  data$QB_Var_Dev[matching_rows] <- baseline_subset$QB_Var_Dev
  data[matching_rows, grep("^Avg ", names(data))] <- 
    baseline_subset[, grep("^Avg ", names(baseline_subset))]
  
  attr(data, "dataset_wide_averages") <- baseline_averages
  
  cat("Iteration", iteration_count, "complete\n")
}
```

```{r}
# Step 5: Final Classification

# Check if Breathing Class exists in data
if (!"Breathing Class" %in% names(data)) {
  stop("Error: 'Breathing Class' column is missing in the data frame before starting classification.")
}

# Iterative Classification Loop
changes_made <- TRUE
iteration_count <- 0
max_iter <- 25

# Store initial Breathing Class for comparison
prev_breathing_class <- rep(NA_real_, nrow(data))
iteration_count <- 0
changes_made <- TRUE

while (changes_made && iteration_count < max_iter) {
  iteration_count <- iteration_count + 1
  changes_made <- FALSE
  
  # Extract session-wide averages
  baseline_averages <- attr(data, "dataset_wide_averages")
  avg_freq <- baseline_averages$Value[baseline_averages$Metric == "Average Frequency"]
  avg_tv <- baseline_averages$Value[baseline_averages$Metric == "Average TV"]
  avg_te <- baseline_averages$Value[baseline_averages$Metric == "Average Te"]
  
  # Print thresholds for inspection
  cat(sprintf("Iteration %d - avg_freq: %.2f, avg_tv: %.2f, avg_te: %.2f\n",
              iteration_count, avg_freq, avg_tv, avg_te))

  classification_subset <- data %>%
    mutate(
      is_qb = !is.na(`QB Tag`),
      is_hypo = (TV <= 0.7 * avg_tv & `Te (msec)` >= 2 * avg_te),
      is_sigh = TV > 2 * avg_tv,
      is_sniff = Frequency > 400,
      is_apnea = `Te (msec)` > 2 * avg_te,
      is_postsigh = (`Te (msec)` >= 2 * avg_te & TV >= 2 * avg_tv)
    ) %>%
    mutate(
      combined_flags = paste(
        ifelse(is_hypo, "4", ""),
        ifelse(is_sigh, "1", ""),
        ifelse(is_sniff, "2", ""),
        ifelse(is_apnea, "3", ""),
        ifelse(is_postsigh, "3.1", ""),
        ifelse(is_qb, "0", ""),
        sep = ","
      ),
      combined_flags = gsub("(^,|,$)", "", combined_flags),
      combined_flags = gsub(",{2,}", ",", combined_flags)
    ) %>%
    rowwise() %>%
    mutate(
      `Breathing Class` = resolve_multiclass(combined_flags)
    ) %>%
    ungroup()
  
  # Debug: Summarize combined_flags for QB-tagged rows
  qb_tagged_rows <- classification_subset %>%
    filter(!is.na(`QB Tag`))
  cat("Iteration", iteration_count, "- combined_flags counts for QB-tagged rows:\n")
  print(table(qb_tagged_rows$combined_flags, useNA = "ifany"))
  cat("Iteration", iteration_count, "- Breathing Class counts for QB-tagged rows:\n")
  print(table(qb_tagged_rows$`Breathing Class`, useNA = "ifany"))
  
  # Debug: Save a subset of data for inspection
  debug_subset <- classification_subset %>%
    filter(!is.na(`QB Tag`)) %>%
    select(orig_index, `QB Tag`, TV, `Te (msec)`, Frequency, is_qb, is_hypo, is_sigh, is_sniff, is_apnea, is_postsigh, combined_flags, `Breathing Class`)
  debug_file <- file.path(tempdir(), paste0("QB_debug_iteration_", iteration_count, ".csv"))
  write.csv(debug_subset, debug_file, row.names = FALSE)
  cat("Debug data for QB-tagged rows saved to:", debug_file, "\n")
  
  # Identify rows that changed class
  changed_rows <- which(
    classification_subset$`Breathing Class` != prev_breathing_class |
    (is.na(classification_subset$`Breathing Class`) != is.na(prev_breathing_class))
  )

  if (length(changed_rows) > 0) {
    changes_made <- TRUE
    cat("Iteration", iteration_count, "- Changed", length(changed_rows),
        "Breathing Class assignments\n")
    
    data$combined_flags <- classification_subset$combined_flags
    data$`Breathing Class` <- classification_subset$`Breathing Class`
    data$is_qb <- classification_subset$is_qb
    data$is_hypo <- classification_subset$is_hypo
    data$is_sigh <- classification_subset$is_sigh
    data$is_sniff <- classification_subset$is_sniff
    data$is_apnea <- classification_subset$is_apnea
    data$is_postsigh <- classification_subset$is_postsigh
    
    # Update tracking fields
    data$combined_flags <- classification_subset$combined_flags
    data$`Breathing Class` <- classification_subset$`Breathing Class`
    
    # Save current classification state
    prev_breathing_class <- classification_subset$`Breathing Class`
    
    # Recalculate averages on confirmed QB rows only
    baseline_subset <- data %>%
      filter(`Breathing Class` == 0, `Protocol Type` %in% baseline_protocol, !is.na(`Period Time`))

    if (nrow(baseline_subset) == 0) {
      warning("No QB rows left for recalculating averages. Stopping iteration.")
      break
    }
    
    baseline_subset <- recalc_qb_tags_and_averages(baseline_subset)
    new_averages <- attr(baseline_subset, "dataset_wide_averages")
    
    # Threshold check: abort if wild change
    if (abs(new_averages$Value[new_averages$Metric == "Average Te"] - avg_te) / avg_te > 0.25) {
      warning("Average Te changed more than 25% from previous iteration â€” aborting to avoid runaway loop.")
      break
    }
    
    # Update data with new QB tag and average fields
    matching_rows <- match(baseline_subset$orig_index, data$orig_index)
    data$`QB Tag`[matching_rows] <- baseline_subset$`QB Tag`
    data$`QB Variability`[matching_rows] <- baseline_subset$`QB Variability`
    data$QB_Var_Dev[matching_rows] <- baseline_subset$QB_Var_Dev
    data[matching_rows, grep("^Avg ", names(data))] <- baseline_subset[, grep("^Avg ", names(baseline_subset))]

    attr(data, "dataset_wide_averages") <- new_averages
  }

  cat("Iteration", iteration_count, "complete\n\n")
}
```

```{r}
# Step 6: Final QB Session Adjustment
# Ensure the dataset is sorted by orig_index
data <- data %>% arrange(orig_index)

# Filter for QB breaths (Breathing Class == 0 and QB Tag is not NA)
qb_breaths <- data %>%
  filter(`Breathing Class` == 0 & !is.na(`QB Tag`)) %>%
  select(orig_index, `QB Tag`, Ttotal, `QB Variability`, `QB_Var_Dev`) %>%
  arrange(orig_index)

# Process index by index to check for gaps and split sessions
# Initialize a counter for new QB Tags
max_qb_tag <- max(qb_breaths$`QB Tag`, na.rm = TRUE)
new_qb_tag_counter <- max_qb_tag

# Add a column to store the new QB Tag, initially copying the original QB Tag
qb_breaths <- qb_breaths %>%
  mutate(new_qb_tag = `QB Tag`)

# Iterate through QB breaths to apply splitting logic
for (i in seq_len(nrow(qb_breaths))) {
  if (i == 1) {
    next  # First QB breath, no previous breath to compare
  }
  
  current_index <- qb_breaths$orig_index[i]
  current_qb_tag <- qb_breaths$`QB Tag`[i]
  prev_index <- qb_breaths$orig_index[i - 1]
  prev_qb_tag <- qb_breaths$`QB Tag`[i - 1]
  
  gap <- current_index - prev_index
  
  if (gap > 5 && current_qb_tag == prev_qb_tag) {
    new_qb_tag_counter <- new_qb_tag_counter + 1
    
    qb_breaths <- qb_breaths %>%
      mutate(
        new_qb_tag = if_else(
          orig_index >= current_index & `QB Tag` == current_qb_tag,
          new_qb_tag_counter,
          new_qb_tag
        )
      )
  }
}

# Remove sessions with fewer than 10 breaths
qb_breaths <- qb_breaths %>%
  group_by(new_qb_tag) %>%
  mutate(breath_count = n()) %>%
  ungroup() %>%
  mutate(new_qb_tag = if_else(breath_count < 10, NA_integer_, new_qb_tag)) %>%
  # Renumber the remaining QB Tags sequentially
  mutate(new_qb_tag = if_else(is.na(new_qb_tag), NA_integer_, as.integer(factor(new_qb_tag)))) %>%
  select(-breath_count)

# Recalculate QB Variability and QB_Var_Dev
qb_breaths <- qb_breaths %>%
  arrange(new_qb_tag, orig_index) %>%
  group_by(new_qb_tag) %>%
  mutate(
    Ttotal_lag = lag(Ttotal),
    `QB Variability` = if_else(
      is.na(Ttotal_lag),
      NA_real_,
      abs((Ttotal - Ttotal_lag) / Ttotal_lag) * 100
    ),
    `QB Variability` = if_else(is.infinite(`QB Variability`), NA_real_, `QB Variability`),
    var_lag = lag(`QB Variability`),
    `QB_Var_Dev` = if_else(
      is.na(var_lag),
      NA_real_,
      abs(`QB Variability` - var_lag)
    )
  ) %>%
  ungroup() %>%
  select(-Ttotal_lag, -var_lag)

# Save original QB Tag before updating in main dataset
data <- data %>%
  mutate(QB_Tag_prev = `QB Tag`)

# Update the main dataset
data <- data %>%
  select(-`QB Tag`, -`QB Variability`, -`QB_Var_Dev`) %>%
  left_join(
    qb_breaths %>% select(orig_index, new_qb_tag, `QB Variability`, `QB_Var_Dev`),
    by = "orig_index"
  ) %>%
  rename(`QB Tag` = new_qb_tag)

# Identify newly removed QB Tags (those that just became NA)
data <- data %>%
  mutate(QB_Tag_was_removed = is.na(`QB Tag`) & !is.na(QB_Tag_prev))

# Ensure only these rows get QB-related columns set to NA
data <- data %>%
  mutate(
    `QB Variability` = if_else(QB_Tag_was_removed, NA_real_, `QB Variability`),
    `QB_Var_Dev` = if_else(QB_Tag_was_removed, NA_real_, `QB_Var_Dev`),
    across(starts_with("Avg"), ~if_else(QB_Tag_was_removed, NA_real_, .)),
           `combined_flags` = if_else(QB_Tag_was_removed, NA, `combined_flags`))%>%
  select(-QB_Tag_prev, -QB_Tag_was_removed)

data <- data %>%
  relocate(`QB Tag`, `QB Variability`, `QB_Var_Dev`, .after = Frequency)
```

```{r}
# Output Processing
metrics <- c("Ti (msec)", "Te (msec)", "PIF", "PEF", "TV", "RT (msec)", "MV", "P (msec)", "Frequency", "Penh", "Ttotal")

get_means <- function(df, class_values, metrics) {
  class_rows <- df[df$`Breathing Class` %in% class_values, ]
  if (nrow(class_rows) == 0) rep(NA, length(metrics)) else sapply(metrics, function(m) mean(class_rows[[m]], na.rm = TRUE))
}

# ADDITION: Create the custom protocol names in the main 'data' table first.
data <- data %>%
  mutate(ProtocolName = case_when(
    protocol_block_id == 1 ~ "Quiet Breathing",
    protocol_block_id == 2 ~ "Hypoxia Chall",
    protocol_block_id == 3 ~ "Normoxia 1",
    protocol_block_id == 4 ~ "Hypercapnia Chall",
    protocol_block_id == 5 ~ "Normoxia 2",
    TRUE ~ as.character(`Protocol Type`) # Fallback for any other blocks
  ))

# --- This section remains as it was in your original code ---
baseline_subset <- data %>% filter(is_baseline_candidate == TRUE)

## Sigh Calculations
sigh_rows <- baseline_subset$orig_index[which(baseline_subset$`Breathing Class` == 1)]
sigh_count <- if (length(sigh_rows) == 0) "NONE" else length(sigh_rows)
sigh_means <- get_means(baseline_subset, 1, metrics)

## Sniff Calculations
sniff_rows <- baseline_subset$orig_index[which(baseline_subset$`Breathing Class` == 2)]
sniff_count <- if (length(sniff_rows) == 0) "NONE" else length(sniff_rows)
sniff_means <- get_means(baseline_subset, 2, metrics)

## Hypopnea Calculations
hypopnea_rows <-  baseline_subset$orig_index[which(baseline_subset$`Breathing Class` == 4)]
hypopnea_count <- if (length(hypopnea_rows) == 0) "NONE" else length(hypopnea_rows)
hypopnea_means <- get_means(baseline_subset, 4, metrics)

## Apnea Calculations
baseline_subset <- baseline_subset %>%
  mutate(`Apnea Type` = ifelse(`Breathing Class` == 3, "General", ifelse(`Breathing Class` == 3.1, "Post-Sigh", NA)))
apnea_rows <- baseline_subset$orig_index[which(baseline_subset$`Breathing Class` %in% c(3, 3.1))]
total_apnea_count <- if (length(apnea_rows) == 0) "NONE" else length(apnea_rows)
total_apnea_means <- get_means(baseline_subset, c(3, 3.1), metrics)
general_apnea_rows <- baseline_subset$orig_index[which(baseline_subset$`Breathing Class` == 3)]
general_apnea_count <- if (length(general_apnea_rows) == 0) "NONE" else length(general_apnea_rows)
general_apnea_means <- get_means(baseline_subset, 3, metrics)
postsigh_apnea_rows <-  baseline_subset$orig_index[which(baseline_subset$`Breathing Class` == 3.1)]
postsigh_apnea_count <- if (length(postsigh_apnea_rows) == 0) "NONE" else length(postsigh_apnea_rows)
postsigh_apnea_means <- get_means(baseline_subset, 3.1, metrics)
# --- End of original section ---


#nPrepare data frames for excel sheets to include the Protocol name.
# This uses the 'sigh_rows' vector calculated above.
sigh_sheet_df <- data.frame(Sigh_Index = sigh_rows) %>%
  left_join(data %>% select(orig_index, Protocol = ProtocolName), by = c("Sigh_Index" = "orig_index")) %>%
  mutate(Sighs = row_number()) %>%
  select(Sighs, Sigh_Index, Protocol)

# Prepare Hypopneas data
hypopnea_sheet_df <- data.frame(Hypopnea_Index = hypopnea_rows) %>%
  left_join(data %>% select(orig_index, Protocol = ProtocolName), by = c("Hypopnea_Index" = "orig_index")) %>%
  mutate(Hypopneas = row_number()) %>%
  select(Hypopneas, Hypopnea_Index, Protocol)
  
# Prepare Apneas data
if (length(apnea_rows) > 0) {
  apnea_table <- data.frame(
    Apnea_Index = apnea_rows
  ) %>%
  left_join(baseline_subset %>% select(orig_index, `Apnea Type`), by = c("Apnea_Index" = "orig_index")) %>%
  left_join(data %>% select(orig_index, Protocol = ProtocolName), by = c("Apnea_Index" = "orig_index")) %>%
  mutate(Index = row_number()) %>%
  select(Index, Apnea_Index, `Apnea Type`, Protocol)
}


# Helper: minutes between start/end indices using 'Site Time', robust to type.
compute_qb_minutes <- function(start_idx, end_idx, st, ttotal = NULL) {
  get_one <- function(s, e) {
    si <- st[s]; ei <- st[e]
    # POSIXct / POSIXt
    if (inherits(st, c("POSIXct","POSIXt")))
      return(as.numeric(difftime(ei, si, units = "mins")))
    # difftime column
    if (inherits(st, "difftime"))
      return(as.numeric(ei - si, units = "mins"))
    # character times like "HH:MM:SS" -> use lubridate::hms
    if (is.character(st)) {
      p <- suppressWarnings(lubridate::hms(st))
      if (!all(is.na(p)))
        return((lubridate::period_to_seconds(p[e]) - lubridate::period_to_seconds(p[s])) / 60)
    }
    # numeric: either seconds or Excel day-fractions
    if (is.numeric(st)) {
      # Heuristic: day-fractions are usually < 5; seconds are large
      if (max(st, na.rm = TRUE) <= 5) {            # fraction of a day
        return((ei - si) * 24 * 60)                # days -> minutes
      } else {                                     # seconds
        return((ei - si) / 60)                     # seconds -> minutes
      }
    }
    # Fallback: if Ttotal is available, approximate by summing that window (ms -> min)
    if (!is.null(ttotal))
      return(sum(ttotal[seq.int(s, e)], na.rm = TRUE) / 60000)
    return(NA_real_)
  }
  vapply(seq_along(start_idx), function(i) get_one(start_idx[i], end_idx[i]), numeric(1))
}


# Add ProtocolName to the QB sessions summary.
data <- data %>% mutate(orig_row = row_number())
baseline_subset <- data %>% filter(is_baseline_candidate == TRUE)

qb_sessions <- baseline_subset %>%
  filter(!is.na(`QB Tag`)) %>%
  group_by(`QB Tag`) %>%
  summarise(
    start_idx = min(orig_row),
    end_idx   = max(orig_row),
    length    = end_idx - start_idx,
    Protocol  = first(ProtocolName),
    `Avg Ti` = mean(`Ti (msec)`, na.rm = TRUE), `Avg Te` = mean(`Te (msec)`, na.rm = TRUE),
    `Avg PIF` = mean(PIF, na.rm = TRUE), `Avg PEF` = mean(PEF, na.rm = TRUE),
    `Avg TV` = mean(TV, na.rm = TRUE), `Avg RT` = mean(`RT (msec)`, na.rm = TRUE),
    `Avg MV` = mean(MV, na.rm = TRUE), `Avg P`  = mean(`P (msec)`, na.rm = TRUE),
    `Avg Frequency` = mean(Frequency, na.rm = TRUE), `Avg Penh` = mean(Penh, na.rm = TRUE),
    `Avg Total` = mean(Ttotal, na.rm = TRUE), `Avg QB Variability` = mean(`QB Variability`, na.rm = TRUE),
    Sum_Ttotal_mins = sum(Ttotal, na.rm = TRUE) / 60000,   # fallback window sum in minutes
    .groups = "drop"
  ) %>%
  mutate(
    QB_Time = if ("Site Time" %in% names(data)) {
      compute_qb_minutes(start_idx, end_idx, data$`Site Time`, ttotal = data$Ttotal)
    } else {
      Sum_Ttotal_mins
    },
    QB_Time = ifelse(is.na(QB_Time), Sum_Ttotal_mins, QB_Time)  # final safety net
  ) %>%
  select(-Sum_Ttotal_mins)

# Totals & rates
QB_Ttime <- sum(qb_sessions$QB_Time, na.rm = TRUE)
sigh_n   <- if (identical(sigh_count, "NONE")) 0 else as.numeric(sigh_count)
apnea_n  <- if (identical(total_apnea_count, "NONE")) 0 else as.numeric(total_apnea_count)
sighs_permin  <- if (QB_Ttime > 0) sigh_n  / QB_Ttime else NA_real_
apneas_permin <- if (QB_Ttime > 0) apnea_n / QB_Ttime else NA_real_
cat("QB_Ttime (min):", QB_Ttime, "\n")
cat("Sighs/min:", sighs_permin, " Apneas/min:", apneas_permin, "\n")

total_qb_sessions <- if (nrow(qb_sessions) == 0) "NONE" else max(as.numeric(qb_sessions$`QB Tag`))


data <- data %>%
  relocate(`Breathing Class`, .after = `Avg Total`)

# Update Avg columns for non-QB breathing classes
data <- data %>%
  mutate(
    `Avg Ti` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[1],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[1],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[1],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[1],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[1],
      TRUE ~ NA_real_
    ),
    `Avg Te` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[2],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[2],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[2],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[2],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[2],
      TRUE ~ NA_real_
    ),
    `Avg PIF` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[3],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[3],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[3],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[3],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[3],
      TRUE ~ NA_real_
    ),
    `Avg PEF` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[4],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[4],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[4],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[4],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[4],
      TRUE ~ NA_real_
    ),
    `Avg TV` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[5],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[5],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[5],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[5],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[5],
      TRUE ~ NA_real_
    ),
    `Avg RT` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[6],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[6],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[6],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[6],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[6],
      TRUE ~ NA_real_
    ),
    `Avg MV` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[7],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[7],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[7],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[7],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[7],
      TRUE ~ NA_real_
    ),
    `Avg P` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[8],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[8],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[8],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[8],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[8],
      TRUE ~ NA_real_
    ),
    `Avg Frequency` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[9],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[9],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[9],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[9],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[9],
      TRUE ~ NA_real_
    ),
    `Avg Penh` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[10],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[10],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[10],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[10],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[10],
      TRUE ~ NA_real_
    ),
    `Avg Total` = case_when(
      is_baseline_candidate == TRUE & `Breathing Class` == 1 ~ sigh_means[11],
      is_baseline_candidate == TRUE & `Breathing Class` == 2 ~ sniff_means[11],
      is_baseline_candidate == TRUE & `Breathing Class` == 3 ~ general_apnea_means[11],
      is_baseline_candidate == TRUE & `Breathing Class` == 3.1 ~ postsigh_apnea_means[11],
      is_baseline_candidate == TRUE & `Breathing Class` == 4 ~ hypopnea_means[11],
      TRUE ~ NA_real_
    )
  )

data <- data %>%
  left_join(
    qb_sessions %>%
      select(`QB Tag`, `Avg Ti`, `Avg Te`, `Avg PIF`, `Avg PEF`, `Avg TV`,
             `Avg RT`, `Avg MV`, `Avg P`, `Avg Frequency`, `Avg Penh`, `Avg Total`),
    by = "QB Tag",
    suffix = c("", ".qb_sessions")
  ) %>%
  mutate(
    `Avg Ti` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg Ti.qb_sessions`,
      TRUE ~ `Avg Ti`
    ),
    `Avg Te` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg Te.qb_sessions`,
      TRUE ~ `Avg Te`
    ),
    `Avg PIF` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg PIF.qb_sessions`,
      TRUE ~ `Avg PIF`
    ),
    `Avg PEF` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg PEF.qb_sessions`,
      TRUE ~ `Avg PEF`
    ),
    `Avg TV` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg TV.qb_sessions`,
      TRUE ~ `Avg TV`
    ),
    `Avg RT` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg RT.qb_sessions`,
      TRUE ~ `Avg RT`
    ),
    `Avg MV` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg MV.qb_sessions`,
      TRUE ~ `Avg MV`
    ),
    `Avg P` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg P.qb_sessions`,
      TRUE ~ `Avg P`
    ),
    `Avg Frequency` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg Frequency.qb_sessions`,
      TRUE ~ `Avg Frequency`
    ),
    `Avg Penh` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg Penh.qb_sessions`,
      TRUE ~ `Avg Penh`
    ),
    `Avg Total` = case_when(
      !is.na(`QB Tag`) & `Breathing Class` == 0 ~ `Avg Total.qb_sessions`,
      TRUE ~ `Avg Total`
    )
  ) %>%
  select(-ends_with(".qb_sessions"))
# --- End of original section ---


# Write the new data frames to the Excel sheets.
# Create the multi-sheet Excel workbook
wb2 <- createWorkbook()

# Sheet 1: Total Counts
addWorksheet(wb2, "Total Counts")
writeData(wb2, "Total Counts", data.frame(
  "Breathing Classification Type" = c("Sigh Count", "Sighs per Min",
                                      "QB Sessions", "QB Total Time",
                                      "Apnea Count (Total)",
                                      "Apnea Count (General)",
                                      "Apnea Count (Postsigh)",
                                      "Apneas per Min", "Hypopnea Count"),
  "Total Number" = c(sigh_count, sighs_permin, total_qb_sessions,QB_Ttime,
                     total_apnea_count, general_apnea_count,
                     postsigh_apnea_count, apneas_permin, hypopnea_count)
), startCol = 1, startRow = 1)
writeData(wb2, "Total Counts", "Avg QB Values", startCol = 5, startRow = 1, colNames = FALSE)
writeData(wb2, "Total Counts", baseline_averages$Metric, startCol = 5, startRow = 2, colNames = FALSE)
writeData(wb2, "Total Counts", baseline_averages$Value, startCol = 6, startRow = 2, colNames = FALSE)

# Sheet 2: Sighs
addWorksheet(wb2, "Sighs")
if (length(sigh_rows) == 0) {
    writeData(wb2, "Sighs", data.frame("Sighs" = "NONE", "Sigh Index" = "NONE", "Protocol" = "NONE"))
} else {
    writeData(wb2, "Sighs", sigh_sheet_df)
}
writeData(wb2, "Sighs", "Avg Sigh Values", startCol = 5, startRow = 1, colNames = FALSE)
writeData(wb2, "Sighs", data.frame(Metric = metrics, Value = sigh_means), startCol = 5, startRow = 2)

# Sheet 3: Quiet Breathing
addWorksheet(wb2, "Quiet Breathing")
quiet_breathing_summary <- qb_sessions %>%
  mutate(Indexes = paste(start_idx, "-", end_idx)) %>%
  select(
    `QB Tag`, Indexes, Protocol, `Length` = length,
    `QB Time` = QB_Time,          # NEW COLUMN here
    Mean_Ti = `Avg Ti`, Mean_Te = `Avg Te`,
    Mean_PIF = `Avg PIF`, Mean_PEF = `Avg PEF`,
    Mean_TV = `Avg TV`, Mean_RT = `Avg RT`,
    Mean_MV = `Avg MV`, Mean_P = `Avg P`,
    Mean_Freq = `Avg Frequency`, Mean_Penh = `Avg Penh`,
    Mean_Ttotal = `Avg Total`, Mean_QB_Var = `Avg QB Variability`)
writeData(wb2, "Quiet Breathing", quiet_breathing_summary, startCol = 1, startRow = 1)

# Sheet 4: Apneas (Consolidated)
addWorksheet(wb2, "Apneas")
if (length(apnea_rows) == 0) {
  writeData(wb2, "Apneas", data.frame(
    "Apneas" = "NONE", "Apnea Index" = "NONE", "Apnea Type" = "NONE", "Protocol" = "NONE"
  ))
} else {
  writeData(wb2, "Apneas", apnea_table)
}
counts_data <- data.frame(
  "Total Apnea Count" = total_apnea_count,
  "General Apnea Count" = general_apnea_count,
  "Post-Sigh Apnea Count" = postsigh_apnea_count
)
writeData(wb2, "Apneas", counts_data, startCol = 6, startRow = 1) # Shifted to make space for new column
averages_data <- data.frame(
  "Metric" = metrics,
  "Avg All Apneas" = total_apnea_means,
  "Avg General Apneas" = general_apnea_means,
  "Avg Post-Sigh Apneas" = postsigh_apnea_means
)
writeData(wb2, "Apneas", averages_data, startCol = 6, startRow = 4) # Shifted

# Sheet 5: Hypopneas
addWorksheet(wb2, "Hypopneas")
if (length(hypopnea_rows) == 0) {
    writeData(wb2, "Hypopneas", data.frame("Hypopneas" = "NONE", "Hypopnea Index" = "NONE", "Protocol" = "NONE"))
} else {
    writeData(wb2, "Hypopneas", hypopnea_sheet_df)
}
writeData(wb2, "Hypopneas", "Avg Hypopneas Values", startCol = 5, startRow = 1, colNames = FALSE)
writeData(wb2, "Hypopneas", data.frame(Metric = metrics, Value = hypopnea_means), startCol = 5, startRow = 2)

# saveWorkbook(wb2, paste0(file_name, "_processed.xlsx"), overwrite = TRUE)
```

```{r}
# Diagnostic check: Save and open temporary QBfilter.xlsx for inspection
temp_file <- file.path(tempdir(), "QBfilter_temp.xlsx")
wb_temp <- createWorkbook()
addWorksheet(wb_temp, "Data")
writeData(wb_temp, "Data", data)
saveWorkbook(wb_temp, file = temp_file, overwrite = TRUE)
cat("Temporary QBfilter.xlsx saved at:", temp_file, "\n")
cat("Opening temporary file for inspection...\n")
if (.Platform$OS.type == "windows") {
  shell(paste("start", temp_file), wait = FALSE)
} else {
  system(paste("open", temp_file), wait = FALSE)
}
cat("Please inspect the temporary QBfilter.xlsx file. Close Excel and press Enter to continue...\n")
readline(prompt = "Press Enter to continue...")
# Optionally clean up the temporary file
# unlink(temp_file)

# Clear QB-related columns based on specified conditions
data <- data %>%
  # 1) Clear QB Tag, QB Variability, QB_Var_Dev, and Breathing Class for baseline rows without transcribed average values
  mutate(
    across(
      c(`QB Tag`, `QB Variability`, `QB_Var_Dev`, `Breathing Class`),
      ~ if_else(
        `Protocol Type` %in% baseline_protocol &
          (is.na(`Avg Ti`) & is.na(`Avg Te`) & is.na(`Avg PIF`) &
             is.na(`Avg PEF`) & is.na(`Avg TV`) & is.na(`Avg RT`) &
             is.na(`Avg MV`) & is.na(`Avg P`) & is.na(`Avg Frequency`) &
             is.na(`Avg Penh`) & is.na(`Avg Total`)),
        NA_real_,
        .
        )
      )
    ) %>%
  # 2) Clear QB Tag, QB Variability, and QB_Var_Dev for rows where Breathing Class != 0
  mutate(
    across(
      c(`QB Tag`, `QB Variability`, `QB_Var_Dev`),
      ~ if_else(
        !is.na(`Breathing Class`) & `Breathing Class` != 0,
        NA_real_,
        .
      )
    )
  )

data <- data %>%
  select(
    all_of(names(data)[!names(data) %in% c("Breathing Class", "is_qb", "is_hypo", "is_sigh", "is_sniff", "is_apnea", "is_postsigh")]),
    `Avg Total`,
    `Breathing Class`,
    is_qb, is_hypo, is_sigh, is_sniff, is_apnea, is_postsigh
  )
```

```{r}
# Create a grob table with the dataset-wide averages and the title heading
average_table_title <- paste("Average Quiet Breathing Values", file_name)

# Create the table grob
table_grob <- tableGrob(baseline_averages, rows = NULL)

# Add the title
title_grob <- textGrob(average_table_title, gp = gpar(fontsize = 15, fontface = "bold"))

# Arrange the title and table in a grid
grob_table <- grid.arrange(title_grob, table_grob, nrow = 2, heights = c(0.2, 1))
```

```{r}


# Prompt user for "Rat Light Type"
rat_light_type <- readline(prompt = "Enter Rat Light Type: ")

# Save the new Excel file in the "Circadian QB Filter" folder
output_folder_filter <- file.path(getwd(), "Circadian QB Filter")
if (!dir.exists(output_folder_filter)) {
  dir.create(output_folder_filter)
}

# Adjust file name based on user input
if (rat_light_type != "LD") {
  file_name <- paste0(rat_light_type, "_", file_name)
}

output_file_filter <- file.path(output_folder_filter, paste0(file_name, "_QBfilter.xlsx"))
# Create a new workbook
wb <- createWorkbook()

# Add a worksheet named "Data"
addWorksheet(wb, "Data")

# Write your data frame to the worksheet
writeData(wb, "Data", data)

# Define styles for each Breathing Class value
style_0 <- createStyle(fgFill = "#FFFF99")  # Light yellow
style_1 <- createStyle(fgFill = "#ADD8E6")  # Light blue
style_2 <- createStyle(fgFill = "#FFB6C1")  # Light red/pink
style_3 <- createStyle(fgFill = "#90EE90")  # Light green
style_3.1 <- createStyle(fgFill = "#00FF7F")  # Spring green
style_4 <- createStyle(fgFill = "#E6E6FA")  # Light purple/violet

# Locate the column index for "Breathing Class"
bc_col <- match("Breathing Class", names(data))

# For each class value, find the row indices and apply the corresponding style
rows_0 <- which(data$`Breathing Class` == 0) + 1  # +1 offset for header row
rows_1 <- which(data$`Breathing Class` == 1) + 1
rows_2 <- which(data$`Breathing Class` == 2) + 1
rows_3 <- which(data$`Breathing Class` == 3) + 1
rows_3.1 <- which(data$`Breathing Class` == 3.1) + 1
rows_4 <- which(data$`Breathing Class` == 4) + 1

# Modify the highlighting section to include all relevant columns
columns_to_highlight <- c(
    "Avg Ti (msec)", "Avg Te (msec)", "Avg TV", "Avg PIF", "Avg PEF", 
    " Avg RT (msec)","Avg MV", " Avg P (msec)", " Avg f (bpm)", " Avg Penh", " Avg Ttotal",
    "Avg QB Variability", "Breathing Class",
    grep("Avg", names(data), value = TRUE)
)

# Get column indices for highlighting
highlight_cols <- match(columns_to_highlight, names(data))
highlight_cols <- highlight_cols[!is.na(highlight_cols)]

# Apply styles to all specified columns for each breathing class
for (col in highlight_cols) {
    if (length(rows_0) > 0) addStyle(wb, sheet = "Data", style_0, rows = rows_0, cols = col, gridExpand = TRUE, stack = TRUE)
    if (length(rows_1) > 0) addStyle(wb, sheet = "Data", style_1, rows = rows_1, cols = col, gridExpand = TRUE, stack = TRUE)
    if (length(rows_2) > 0) addStyle(wb, sheet = "Data", style_2, rows = rows_2, cols = col, gridExpand = TRUE, stack = TRUE)
    if (length(rows_3) > 0) addStyle(wb, sheet = "Data", style_3, rows = rows_3, cols = col, gridExpand = TRUE, stack = TRUE)
  if (length(rows_3.1) > 0) addStyle(wb, sheet = "Data", style_3.1, rows = rows_3.1, cols = col, gridExpand = TRUE, stack = TRUE)
    if (length(rows_4) > 0) addStyle(wb, sheet = "Data", style_4, rows = rows_4, cols = col, gridExpand = TRUE, stack = TRUE)
}

# Finally, save the new Excel file
saveWorkbook(wb, file = output_file_filter, overwrite = TRUE)

# Save the grob table in the "Circadian QB Avg Tables" folder
output_folder_avg <- file.path(getwd(), "Circadian QB Avg Tables")
if (!dir.exists(output_folder_avg)) {
  dir.create(output_folder_avg)
}

output_file_avg <- file.path(output_folder_avg, paste0(file_name, "_QB_AVG.png"))
ggsave(output_file_avg, grob_table, width = 10, height = 5)


# "Classification Count" output
# Create directories if they don't exist
class_count_folder <- file.path(getwd(), "Classification Count")
if (!dir.exists(class_count_folder)) {
  dir.create(class_count_folder)
}

# Create file paths
output_file_breathing <- file.path(class_count_folder, paste0(file_name, "_BreathingAnalysis.xlsx"))

# Save the workbook with multiple sheets
saveWorkbook(wb2, output_file_breathing, overwrite = TRUE)

# Print confirmation messages
cat("Excel file saved as:", output_file_filter, "\n")
cat("Grob table saved as:", output_file_avg, "\n")
cat("Breathing Analysis summary saved as:", output_file_breathing, "\n")
```